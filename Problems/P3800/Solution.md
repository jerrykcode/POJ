## DP+单调队列优化

dp[i][j]表示在(i, j)位置向下走能得到的最大power  
最终答案即 max{dp[0][j]}  
显然最下面一行 dp[n - 1][j] 的值即(n - 1, j)位置的value  
而转移方程 dp[i][j] = max{dp[i + 1][k]} + (i, j)位置的value, 其中 k >= j - t && k <= j + t && k >= 0 && k < m  
枚举i, j, k的复杂度为O(n的3次方)，可以用单调队列优化  
对于每一行i, 当j = 0时，k需要从[0, t]中间取值，而当j每次增1，k的取值范围都会向右移1，  
即若对于j, k的取值范围是[j - t, j + t]，那么对于j + 1, k的取值范围是[j + 1 - t, j + 1 + t]  
对这个范围中的每个k, 用单调队列维护dp[i + 1][k]，当j增1，单调队列Push新值dp[i + 1][j + t], 同时将过期的值出队  
队列中的最大值加上(i, j)位置的value即dp[i][j]  
