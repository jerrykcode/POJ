# P2690 接苹果
[原题地址](https://www.luogu.com.cn/problem/P2690)  

## 题目背景

USACO
## 题目描述

很少有人知道奶牛爱吃苹果。农夫约翰的农场上有两棵苹果树（编号为1和2）， 每一棵树上都长满了苹果。奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果 从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。每一分钟，两棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在两棵树之间 快速移动（移动时间远少于1分钟），因此当苹果掉落时，她必定站在两棵树其中的一棵下面。此外，奶牛不愿意不停地往返于两棵树之间，因此会错过一些苹果。苹果每分钟掉落一个，共T（1<=T<=1000）分钟，贝茜最多愿意移动W（1<=W<=30） 次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在1号树下。
## 输入格式

第一行2个数，T和W。接下来的t行，每行一个数，代表在时刻t苹果是从1号苹果树还是从2号苹果树上掉下来的。
## 输出格式

对于每个测试点，输出一行，一个数，为奶牛最多接到的苹果的数量。
## 输入输出样例
### 输入 #1

7 2  
2  
1  
1  
2  
2  
1  
1  

## 输出 #1

6


## 思路
DP: dp[i][j]表示对前i个苹果转移了j次, 能接到的苹果数量.  
初始化: 对0 <= j <= w, dp[0][j] = 0 (代码中不需要专门为此memset, 因为dp数组初始就是全0)  
状态转移: 前i个苹果转移了j次, 那么可以前i - 1个苹转移j次而第i个苹果掉下来时不转移, 即dp[i - 1][j],   
在j > 0时也可能前i - 1个苹果转移j - 1次然后再第i个苹果掉下来时转移1次, 即dp[i - 1][j - 1],  
然后看第i个苹果能否被接住, 由于总共转移了j次, 那么在j为偶数时相当于没有转移, 牛在初始位置1,   
j为奇数时则牛在位置2,  

![](https://wx1.sinaimg.cn/mw690/006XXwaCgy1gbpfy55omij306s0403ye.jpg)

luogu的markdown好像显示不了表格, 只好截个图了

显然, j % 2 + 1就是转移了j次后牛的位置.  
那么只要第i个苹果掉下来的位置等于j % 2 + 1, dp[i][j]就增1.  
状态转移方程分成3步写:  
```c
dp[i][j] = dp[i - 1][j]; //前i - 1个苹果转移了j次的情况  
if (j > 0) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]); //前i - 1个苹果转移了j - 1次的情况  
if (a == (j % 2 + 1)) dp[i][j]++; //a为第i个苹果掉下来的位置, 若能接住则dp[i][j]++  
```
计算最终结果: 对0 <= j <= w, dp[t][j]中的最大值即所求结果  

也可以将dp压缩成1维数组, 只需要j从w往0循环就可以了.  

## 代码 dp二维
```c
#include "stdio.h"
#include "stdlib.h"

int dp[1001][31];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int t, w, a;
    scanf("%d %d", &t, &w);
    for (int i = 1; i <= t; i++) {
        scanf("%d", &a);
        for (int j = 0; j <= w; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j > 0) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
            if (a == (j % 2 + 1)) dp[i][j]++;
        }
    }
    int res = 0;
    for (int j = 0; j <= w; j++)
        res = max(res, dp[t][j]);
    printf("%d", res);
    return 0;
}
```

## 代码 dp一维

```c
#include "stdio.h"
#include "stdlib.h"

int dp[31];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int t, w, a;
    scanf("%d %d", &t, &w);
    for (int i = 1; i <= t; i++) {
        scanf("%d", &a);
        for (int j = w; j >= 0; j--) {            
            if (j > 0) dp[j] = max(dp[j], dp[j - 1]);
            if (a == (j % 2 + 1)) dp[j]++;
        }
    }
    int res = 0;
    for (int j = 0; j <= w; j++)
        res = max(res, dp[j]);
    printf("%d", res);
    return 0;
}
```

